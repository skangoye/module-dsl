/*
* generated by Xtext
*/ grammar DebugInternalModuleDsl ;

// Rule LANGUAGE

ruleLANGUAGE :
	ruleMODULE_DECL+
;

// Rule MODULE_DECL
 ruleMODULE_DECL :
	'module' RULE_IDENT '{' ruleSTRATEGY ruleINTERFACE ruleBODY '}'
;

// Rule STRATEGY
 ruleSTRATEGY :
	'@' 'strategy' '{' ruleCRITERION_DECL ruleDATASEL_DECL '}'
;

// Rule INTERFACE
 ruleINTERFACE :
	'@' 'interface' '{' ruleVAR_CST+ '}'
;

// Rule BODY
 ruleBODY :
	'@' 'body' '{' ruleINSTRUCTION+ '}'
;

// Rule CRITERION_DECL
 ruleCRITERION_DECL :
	'crit' ':' ruleCRITERION ruleEND
;

// Rule DATASEL_DECL
 ruleDATASEL_DECL :
	'datasel' ':' ruleDATASEL (
		',' ruleDATASEL
	)? ruleEND
;

// Rule END
 ruleEND :
	';'
;

// Rule CRITERION
 ruleCRITERION :
	'mcdc' |
	'dc' |
	'cc'
;

// Rule DATASEL
 ruleDATASEL :
	'rand' |
	'eqv' |
	'bv'
;

// Rule VAR_CST
 ruleVAR_CST :
	ruleVAR |
	ruleCST
;

// Rule VAR
 ruleVAR :
	ruleFlow RULE_IDENT ':' ruleTYPE ruleRANGE? ruleEND
;

// Rule Flow
 ruleFlow :
	'in' |
	'out' |
	'inout' |
	'tmp'
;

// Rule CST
 ruleCST :
	'cst' RULE_IDENT '==' ruleTYPE '(' ruleLiteral ')' ruleEND
;

// Rule TYPE
 ruleTYPE :
	'int' |
	'real' |
	'bool' |
	'enum' |
	'bit' |
	'hex' |
	'str'
;

// Rule RANGE
 ruleRANGE :
	ruleINTERVAL |
	ruleLSET
;

// Rule INTERVAL
 ruleINTERVAL :
	(
		']' |
		'['
	) ruleLiteral '..' ruleLiteral (
		']' |
		'['
	)
;

// Rule LSET
 ruleLSET :
	'{' ruleLiteral (
		',' ruleLiteral
	)* '}'
;

// Rule Literal
 ruleLiteral :
	ruleINTEGER |
	ruleDECIMAL |
	RULE_BOOLEAN |
	RULE_STRING |
	RULE_ENUM_ELEMENT |
	RULE_BIT |
	RULE_HEX |
	'?'
;

// Rule INSTRUCTION
 ruleINSTRUCTION :
	ruleIF_INSTR |
	ruleLOOP_INSTR |
	ruleASSIGN_INSTR |
	ruleERROR_INSTR |
	ruleNULL_INSTR
;

// Rule IF_INSTR
 ruleIF_INSTR :
	'if' '(' ruleEXPRESSION ')' '=>'? '{' ruleINSTRUCTION '}' (
		( (
		'else'
		) => 'else' ) '=>'? '{' ruleINSTRUCTION '}'
	)
;

// Rule LOOP_INSTR
 ruleLOOP_INSTR :
	'loop' '(' RULE_INT ')'
;

// Rule ERROR_INSTR
 ruleERROR_INSTR :
	'error' ruleEND
;

// Rule NULL_INSTR
 ruleNULL_INSTR :
	'null' ruleEND
;

// Rule ASSIGN_INSTR
 ruleASSIGN_INSTR :
	ruleSINGLE_ASSIGN (
		',' ruleSINGLE_ASSIGN
	)* ruleEND
;

// Rule SINGLE_ASSIGN
 ruleSINGLE_ASSIGN :
	ruleEXPRESSION '=' ruleEXPRESSION
;

// Rule EXPRESSION
 ruleEXPRESSION :
	ruleOR
;

// Rule OR
 ruleOR :
	ruleAND (
		'or' ruleAND
	)*
;

// Rule AND
 ruleAND :
	ruleEQUAL_DIFF (
		'and' ruleEQUAL_DIFF
	)*
;

// Rule EQUAL_DIFF
 ruleEQUAL_DIFF :
	ruleCOMPARISON (
		(
			'==' |
			'!='
		) ruleCOMPARISON
	)*
;

// Rule COMPARISON
 ruleCOMPARISON :
	ruleADD_SUB (
		(
			'<' |
			'<=' |
			'>' |
			'>='
		) ruleADD_SUB
	)*
;

// Rule ADD_SUB
 ruleADD_SUB :
	ruleMULT_DIV (
		(
			'+' |
			'-'
		) ruleMULT_DIV
	)*
;

// Rule MULT_DIV
 ruleMULT_DIV :
	rulePrimaryExpression (
		(
			'*' |
			'/'
		) rulePrimaryExpression
	)*
;

// Rule PrimaryExpression
 rulePrimaryExpression :
	'(' ruleEXPRESSION ')' |
	'not' rulePrimaryExpression |
	ruleAtomic
;

// Rule Atomic
 ruleAtomic :
	ruleINTEGER |
	ruleDECIMAL |
	RULE_STRING |
	RULE_ENUM_ELEMENT |
	RULE_BOOLEAN |
	RULE_BIT |
	RULE_HEX |
	RULE_IDENT
;

// Rule DECIMAL
 ruleDECIMAL :
	'-'? RULE_INT (
		'.' RULE_INT
	)
;

// Rule INTEGER
 ruleINTEGER :
	'-'? RULE_INT
;

RULE_ENUM_ELEMENT :
	'_' RULE_IDENT
;

RULE_BOOLEAN :
	'true' |
	'false'
;

RULE_HEX :
	'0x' (
		'0' .. '9' |
		'A' .. 'F'
	)+
;

RULE_IDENT :
	(
		'a' .. 'z' |
		'A' .. 'Z'
	) (
		'a' .. 'z' |
		'A' .. 'Z' |
		'_' |
		'0' .. '9'
	)*
;

RULE_BIT :
	'$' (
		'0' |
		'1'
	)+
;

RULE_ID :
	'^'? (
		'a' .. 'z' |
		'A' .. 'Z' |
		'_'
	) (
		'a' .. 'z' |
		'A' .. 'Z' |
		'_' |
		'0' .. '9'
	)*
;

RULE_INT :
	'0' .. '9'+
;

RULE_STRING :
	'"' (
		'\\' (
			'b' |
			't' |
			'n' |
			'f' |
			'r' |
			'u' |
			'"' |
			'\'' |
			'\\'
		) |
		~ (
			'\\' |
			'"'
		)
	)* '"' |
	'\'' (
		'\\' (
			'b' |
			't' |
			'n' |
			'f' |
			'r' |
			'u' |
			'"' |
			'\'' |
			'\\'
		) |
		~ (
			'\\' |
			'\''
		)
	)* '\''
;

RULE_ML_COMMENT :
	'/*' (
		options { greedy = false ; } : .
	)* '*/' {skip();}
;

RULE_SL_COMMENT :
	'//' ~ (
		'\n' |
		'\r'
	)* (
		'\r'? '\n'
	)? {skip();}
;

RULE_WS :
	(
		' ' |
		'\t' |
		'\r' |
		'\n'
	)+ {skip();}
;

RULE_ANY_OTHER :
	.
;