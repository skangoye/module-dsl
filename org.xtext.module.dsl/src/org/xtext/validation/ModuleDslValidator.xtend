/*
 * generated by Xtext
 */
 
package org.xtext.validation

import org.xtext.types.*
import org.eclipse.xtext.validation.Check
import org.xtext.moduleDsl.*
import java.lang.*
import static extension org.eclipse.emf.ecore.util.EcoreUtil.*
import static extension org.eclipse.xtext.EcoreUtil2.*
import com.google.inject.Inject
import org.eclipse.emf.ecore.EReference

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class ModuleDslValidator extends AbstractModuleDslValidator {
	
public static val INVALID_NAME = 'invalidName'  
public static val INVALID_INPUT = 'invalidInput'  
	
	/**
	 * Verify that module name is unique
	 */
	
	@Check
	def checkModuleNameIsUnique (MODULE_DECL module) {
		val lang = module.getContainerOfType(LANGUAGE)
		val dup = lang.modules.findFirst[it != module && it.name == module.name]
			if (dup != null) {	
				error("Duplicate module name " + module.name + "!", 
					ModuleDslPackage.Literals.MODULE_DECL__NAME, INVALID_NAME )
			}	
	}
	
	@Check
	def checkCriterionDecl(CRITERION_DECL decl){
		val criterion = decl.crit
		if (criterion == null ){
			error("Test criterion is not defined", null)
		}
		else {  val end = decl.end.end
				if ( end == null) {
				error("Syntax error,insert ';' to complete field declaration", ModuleDslPackage.Literals.CRITERION_DECL__CRIT)
			   }
		}
	}
	
	@Check
	def checkDataSelDecl(DATASEL_DECL decl){
		val data1 = decl.data1
		val data2 = decl.data2
		if (data1 == null && data2 == null ){
			error("Test data selection policy is not defined", null)
		}
		else {  val end = decl.end.end
				if ( end == null ) {
			     if (data2 == null){
					error("Syntax error,insert ';' to complete field declaration", ModuleDslPackage.Literals.DATASEL_DECL__DATA1)
			   	 }
			   	 else {
			   	 	error("Syntax error,insert ';' to complete field declaration", ModuleDslPackage.Literals.DATASEL_DECL__DATA2)
			   	 }
			   }
		}
	}
	
	//Check that data selection criteria are distinct
	@Check
	def checkDataSelectElementsAreDif(DATASEL data) {
		val module = data.getContainerOfType(MODULE_DECL)
		val data1 = module.dataseldecl.data1
		val data2 = module.dataseldecl.data2
			 if  (data1.sel == data2?.sel)  {
				error("Test data selection criteria must be distinct!", 
					ModuleDslPackage.Literals.DATASEL__SEL, INVALID_INPUT )
			 }		
	}
	
	@Check
	def checkVarDecl(VAR v){
		val flow = v.flow.flow
		val name = v.name
		//val type = v.type
		
		/*System.out.println(v.flow)
		System.out.println(flow)
		System.out.println(name)
		System.out.println(v.type)
		System.out.println(v.end)
		System.out.println(v.end.end)*/
		
		if (flow != null){
			if (name == null){
				error("Incomplete variable declaration, variable name is expected", 
					null)
			}
			else{ 
				if (v.type == null){ ///////////////
					error("Variable type must be declared", ModuleDslPackage.Literals.VAR_CST__NAME)
				}
				else {
					if (v.type.type == 'enum' && v.range == null) {
						error("An Enumeration variable must declare a set of values!", 
						ModuleDslPackage.Literals.VAR_CST__TYPE)
					}
					else {
						if (v.end.end==null) {
							error("Syntax error,insert ';' to complete field declaration", ModuleDslPackage.Literals.VAR_CST__TYPE)
						}
					}
				}
			}
		}
	}
	
	@Check
	def checkIntervalminMaxValues(INTERVAL interval){
		
		val mintype = interval?.min?.typeProvider
		val maxtype = interval?.max?.typeProvider
		
		if ( mintype == maxtype){
			
			val commonType = mintype
			
			if (commonType == 'int'){
				val minval = interval?.min as intLITERAL
				val maxval = interval?.max as intLITERAL
				if (minval.value >= maxval.value) {
					error("Incorrect Interval declaration, low bound value can't be >= to upper bound value",
						 ModuleDslPackage.Literals.INTERVAL__MIN)
				}
			}
			
			if (commonType == 'real'){
				val minval = interval?.min as realLITERAL
				val maxval = interval?.max as realLITERAL
				if (minval.value >= maxval.value) {
					error("Incorrect Interval declaration, lower bound value can't be >= to upper bound value",
						 ModuleDslPackage.Literals.INTERVAL__MIN)
				}
			}
			
			////TODO Add other variables that allow Intervals: bit, hex
			
			
		}
	}
	
	@Check
 	def checkVarRange(RANGE range){
 		range.checkRange
 	}
 	
	def dispatch checkRange(INTERVAL interval){
		
		val vartype = interval.getContainerOfType(VAR).type
		
		if (vartype == null){
			return //no check
		}
		else{
			val typeVal = vartype.type
			if (typeVal == 'bool') {
				error("Interval is not allowed for Boolean types", null)
			}
			else {
				if (typeVal == 'str') {
					error("Interval is not allowed for String types", null)
				}
				else {
					if (typeVal == 'enum') {
						error("Interval is not allowed for Enumeration types", null)
					}
				} 
			}
			
		}
	}
	
	def dispatch checkRange(LSET set){
		
		val vartype = set.getContainerOfType(VAR).type
		if(vartype == null){
			return
		}
		else{
			if (vartype.type == 'bool'){
				error("Set is not allowed for Boolean types", null)
			}
		}
	}


	@Check
	def checkRangeLiteralType(Literal literal) {
		
		val vartype = literal.getContainerOfType(VAR)?.type.type
		val literaltype = literal.typeProvider
		
		if (vartype != null || vartype != 'bool'){
			checkLiteralInRange (literal, literaltype, vartype)
		}		
	}
	
	def dispatch checkLiteralInRange(intLITERAL literal, String literaltype, String vartype){
		
		if (literaltype != vartype) {
			error("The value must be of type " + vartype + "!", 
					ModuleDslPackage.Literals.INT_LITERAL__VALUE) //We can add some infos (for instance ""actual value is type xxx)
		}
	}
	
	def dispatch checkLiteralInRange(realLITERAL literal, String literaltype, String vartype){
		
		if (literaltype != vartype) {
			error("The value must be of type " + vartype + "!", 
					ModuleDslPackage.Literals.REAL_LITERAL__VALUE)
		}
	}
	
	def dispatch checkLiteralInRange(enumLITERAL literal, String literaltype, String vartype){
		
		if (literaltype != vartype) {
			error("The value must be of type " + vartype + "!", 
					ModuleDslPackage.Literals.ENUM_LITERAL__VALUE)
		}
	}
	
	def dispatch checkLiteralInRange(boolLITERAL literal, String literaltype, String vartype){
		
		if (literaltype != vartype) {
			error("The value must be of type " + vartype + "!", 
					ModuleDslPackage.Literals.BOOL_LITERAL__VALUE)
		}
	}
	
	def dispatch checkLiteralInRange(strLITERAL literal, String literaltype, String vartype){
		
		if (literaltype != vartype) {
			error("The value must be of type " + vartype + "!", 
					ModuleDslPackage.Literals.STR_LITERAL__VALUE)
		}
	}
	
	def dispatch checkLiteralInRange(bitLITERAL literal, String literaltype, String vartype){
		
		if (literaltype != vartype) {
			error("The value must be of type " + vartype + "!", 
					ModuleDslPackage.Literals.BIT_LITERAL__VALUE)
		}
	}
	
	def dispatch checkLiteralInRange(hexLITERAL literal, String literaltype, String vartype){
		
		if (literaltype != vartype) {
			error("The value must be of type " + vartype + "!", 
					ModuleDslPackage.Literals.HEX_LITERAL__VALUE)
		}
	}
	
	def dispatch checkLiteralInRange(identLITERAL literal, String literaltype, String vartype){
		
		if (literaltype != vartype) {
			error("The value must be of type " + vartype + "!", 
					ModuleDslPackage.Literals.IDENT_LITERAL__VALUE)
		}
	}
	 
	def dispatch checkLiteralInRange(unknowLITERAL literal, String literaltype, String vartype){
		
		val range = literal.getContainerOfType(RANGE)
		if (range instanceof LSET) {
			error("Unknow literal '?' connot be used as a Set Value", 
					ModuleDslPackage.Literals.UNKNOW_LITERAL__VALUE)
		}
	}
	
	def String typeProvider(Literal literal) {
		switch (literal){
			intLITERAL: 'int'
			realLITERAL: 'real'
			boolLITERAL: 'bool'
			strLITERAL: 'str'
			enumLITERAL: 'enum'
			bitLITERAL: 'bit'
			hexLITERAL: 'hex'
			identLITERAL: 'ident'
			unknowLITERAL: 'neutral'
		}
	}
	
	/**
	 * Verify that there is no duplicated literal in a Set  of literals,
	 * Indeed, our concept of literal Set does not allow duplicated literals
	 */
	
	@Check
	def checkNoDuplicatedLiterals(Literal literal){
		val vartype = literal.getContainerOfType(VAR)?.type.type
		NoDupLiteralInSet(literal, vartype)
	}
	
	def dispatch NoDupLiteralInSet(intLITERAL literal, String vartype){
	//Check that there is no duplicated literals
		val set = literal.getContainerOfType(LSET)
		if (set != null){
			val valList = set.value 
			val diftype = valList.exists[ it.typeProvider != vartype ]
			if (!diftype){
				val dup = valList.findFirst[(it as intLITERAL  != literal) && ((it as intLITERAL).value == literal.value)]
			    if (dup != null) {	
					error("Elements of a Set must be distinct", 
						ModuleDslPackage.Literals.INT_LITERAL__VALUE)
				}	
			}
			
		}
	}
	
	def dispatch NoDupLiteralInSet(realLITERAL literal, String vartype){
		//Check that there is no duplicated literals
		val set = literal.getContainerOfType(LSET)
		if (set != null){
			val valList = set.value 
			val diftype = valList.exists[ it.typeProvider != vartype ]
			if (!diftype){
				val dup = valList.findFirst[(it as realLITERAL  != literal) && ((it as realLITERAL).value == literal.value)]
			    if (dup != null) {	
					error("Elements of a Set must be distinct", 
						ModuleDslPackage.Literals.REAL_LITERAL__VALUE)
				}	
			}	
		}
	}
	
	def dispatch NoDupLiteralInSet(bitLITERAL literal, String vartype){
		//Check that there is no duplicated literals
		val set = literal.getContainerOfType(LSET)
		if (set != null){
			val valList = set.value
			val diftype = valList.exists[ it.typeProvider != vartype ]
			if (!diftype){
				val dup = valList.findFirst[(it as bitLITERAL  != literal) && ((it as bitLITERAL).value == literal.value)]
			    if (dup != null) {	
					error("Elements of a Set must be distinct", 
						ModuleDslPackage.Literals.BIT_LITERAL__VALUE)
				}	
			}	
		}
	}
	
	def dispatch NoDupLiteralInSet(hexLITERAL literal, String vartype){
		//Check that there is no duplicated literals
		val set = literal.getContainerOfType(LSET)
		if (set != null){
			val valList = set.value 
			val diftype = valList.exists[ it.typeProvider != vartype ]
			if (!diftype){
				val dup = valList.findFirst[(it as hexLITERAL  != literal) && ((it as hexLITERAL).value == literal.value)]
			    if (dup != null) {	
					error("Elements of a Set must be distinct", 
						ModuleDslPackage.Literals.HEX_LITERAL__VALUE)
				}	
			}	
		}
	}
	
	def dispatch NoDupLiteralInSet(enumLITERAL literal, String vartype){
		//Check that there is no duplicated literals
		val set = literal.getContainerOfType(LSET)
		if (set != null){
			val valList = set.value 
			val diftype = valList.exists[ it.typeProvider != vartype ]
			if (!diftype){
				val dup = valList.findFirst[(it as enumLITERAL  != literal) && ((it as enumLITERAL).value == literal.value)]
			    if (dup != null) {	
					error("Elements of a Set must be distinct", 
						ModuleDslPackage.Literals.ENUM_LITERAL__VALUE)
				}	
			}	
		}
	}
	
	def dispatch NoDupLiteralInSet(strLITERAL literal, String vartype){
		//Check that there is no duplicated literals
		val set = literal.getContainerOfType(LSET)
		if (set != null){
			val valList = set.value
			val diftype = valList.exists[ it.typeProvider != vartype ]
			if (!diftype){
				val dup = valList.findFirst[(it as strLITERAL  != literal) && ((it as strLITERAL).value == literal.value)]
			    if (dup != null) {	
					error("Elements of a Set must be distinct", 
						ModuleDslPackage.Literals.STR_LITERAL__VALUE)
				}	
			}	
		}
	}
	
	def dispatch NoDupLiteralInSet(boolLITERAL literal, String vartype){
		return
	}
	
	def dispatch NoDupLiteralInSet(identLITERAL literal, String vartype){
		return
	}
	
	def dispatch NoDupLiteralInSet(unknowLITERAL literal, String vartype){
		return
	}
	
	/**
	 * verify that variable or constant declaration name is unique among
	 * the all declared variables and constants
	 */
	 
	@Check
	def checkVarOrConstNameIsUnique(VAR_CST v) {
		val varcst = v.getContainerOfType(MODULE_DECL).declaration
		val dup = varcst.findFirst[ (it != v && it.name == v.name) ]
		if (dup != null){
			error("Variable or constant name should be unique", 
					ModuleDslPackage.Literals.VAR_CST__NAME, INVALID_NAME )
		}
	}
	
	/**
	 * 
	 */
	 
	 @Check
	 def checkConstDecl(CST const){
	 	val flow = const.flow
	 	if (flow != null){
	 		val name = const.name
			if (name == null){
				error("Incomplete constant declaration, constant name is expected", null)
			}
			else{  
				if (const.type == null){ ///////////////
					error("constant type must be declared", ModuleDslPackage.Literals.VAR_CST__NAME)
				}
				else {
					if ( const.value == null) {
						error("Constant Value is expected", ModuleDslPackage.Literals.VAR_CST__TYPE)
					}
					else {
						val type = const.type.type
						if (type != const.value.typeProvider){
							error("The value must be of type " + type, ModuleDslPackage.Literals.CST__VALUE)
						}
						else { if(const.end.end==null) {
									error("Syntax error,insert ';' to complete field declaration", ModuleDslPackage.Literals.VAR_CST__TYPE)
								}
						}
					}
				}
			}
		}
	 }
	 
	 @Inject extension ExpressionsTypeProvider
	 
	 
	 def private String getNonNullType(EXPRESSION exp, EReference ref){
	 	var type = exp?.typeFor
	 	if(type == null){
	 		error("null type", ref)
	 	}
	 	return type
	 }
	 
	 def private checkExpectedBoolean(EXPRESSION exp, EReference ref){
	 	checkExpectedType(exp, ExpressionsTypeProvider::boolType,ref)
	 }
	 
	 def private checkNotBoolean(String type, EReference ref){
	 	if (type == ExpressionsTypeProvider::boolType){
	 		error("cannot be boolean", ref)
	 	}
	 }
	 
	 def private checkNotString(String type, EReference ref){
	 	if (type == ExpressionsTypeProvider::strType){
	 		error("cannot be string", ref)
	 	}
	 }
	 
	 def private checkNotEnum(String type, EReference ref){
	 	if (type == ExpressionsTypeProvider::boolType){
	 		error("cannot be enumeration", ref)
	 	}
	 }
	 
	 def private checkNotIntandNotReal(String type, EReference ref){
	 	if (type != ExpressionsTypeProvider::intType && type != ExpressionsTypeProvider::realType ){
	 		error("expected intType or realType, but was "+ type, ref)
	 	}
	 }
	 
	 def private checkExpectedType(EXPRESSION exp, String expectedType,EReference ref){
	 	val actualType = getNonNullType(exp,ref)
	 	if(actualType != expectedType){
	 		error("expected " + expectedType + " type, but was "+ actualType, ref)
	 	}
	 }
	 
	 def private checkExpectedSame(String leftType, String rightType){
	 	if(leftType != null && rightType!= null && leftType != rightType){
	 		error("expected the same type, but was " + leftType+ ", " + rightType, null)
	 	}
	 }
	 
	 @Check
	 def checkType(NOT not){
	 	checkExpectedBoolean(not.exp, ModuleDslPackage.Literals.NOT__EXP)
	 }
	 
	 @Check
	 def checkType(AND and){
	 	checkExpectedBoolean(and.left, ModuleDslPackage.Literals.AND__LEFT)
	 	checkExpectedBoolean(and.right, ModuleDslPackage.Literals.AND__RIGHT)
	 }
	 
	 @Check
	 def checkType(OR or){
	 	checkExpectedBoolean(or.left, ModuleDslPackage.Literals.OR__LEFT)
	 	checkExpectedBoolean(or.right, ModuleDslPackage.Literals.OR__RIGHT)
	 }
	 
	 @Check
	 def checkType(MULT mult){
	 	val leftType = getNonNullType(mult.left, ModuleDslPackage.Literals.MULT__LEFT)
	 	val rightType = getNonNullType(mult.right, ModuleDslPackage.Literals.MULT__RIGHT)
	 	
	 	checkNotIntandNotReal(leftType, ModuleDslPackage.Literals.MULT__LEFT)
	 	checkNotIntandNotReal(rightType, ModuleDslPackage.Literals.MULT__RIGHT)
	 }
	 
	 @Check
	 def checkType(DIV div){
	 	val leftType = getNonNullType(div.left, ModuleDslPackage.Literals.DIV__LEFT)
	 	val rightType = getNonNullType(div.right, ModuleDslPackage.Literals.DIV__RIGHT)
	 	
	 	checkNotIntandNotReal(leftType, ModuleDslPackage.Literals.DIV__LEFT)
	 	checkNotIntandNotReal(rightType, ModuleDslPackage.Literals.DIV__RIGHT)
	 }
	 
	 @Check
	 def checkType(SUB sub){
	 	val leftType = getNonNullType(sub.left, ModuleDslPackage.Literals.SUB__LEFT)
	 	val rightType = getNonNullType(sub.right, ModuleDslPackage.Literals.SUB__RIGHT)
	 	
 		checkNotIntandNotReal(leftType, ModuleDslPackage.Literals.SUB__LEFT)
	 	checkNotIntandNotReal(rightType, ModuleDslPackage.Literals.SUB__RIGHT)
	 }
	 
	 @Check
	 def checkType(COMPARISON comp){
	 	val leftType = getNonNullType(comp.left, ModuleDslPackage.Literals.COMPARISON__LEFT)
	 	val rightType = getNonNullType(comp.right, ModuleDslPackage.Literals.COMPARISON__RIGHT)
	 	
	 	checkExpectedSame(leftType, rightType)
	 	
	 	checkNotBoolean(leftType, ModuleDslPackage.Literals.COMPARISON__LEFT)
	 	checkNotBoolean(rightType, ModuleDslPackage.Literals.COMPARISON__RIGHT)
	 	
	 	checkNotString(leftType, ModuleDslPackage.Literals.COMPARISON__LEFT)
	 	checkNotString(rightType, ModuleDslPackage.Literals.COMPARISON__RIGHT)
	 	
	 	checkNotEnum(leftType, ModuleDslPackage.Literals.COMPARISON__LEFT)
	 	checkNotEnum(rightType, ModuleDslPackage.Literals.COMPARISON__RIGHT)
	 }
	 
	 @Check
	 def checkType(EQUAL_DIFF eqdif){
	 	val leftType = getNonNullType(eqdif.left, ModuleDslPackage.Literals.EQUAL_DIFF__LEFT)
	 	val rightType = getNonNullType(eqdif.right, ModuleDslPackage.Literals.EQUAL_DIFF__RIGHT)
	 	
	 	checkExpectedSame(leftType, rightType)
	 }
	 
	 @Check
	 def checkType(ADD add){
	 	val leftType = getNonNullType(add.left, ModuleDslPackage.Literals.EQUAL_DIFF__LEFT)
	 	val rightType = getNonNullType(add.right, ModuleDslPackage.Literals.EQUAL_DIFF__RIGHT)
	 	
	 	if ( (leftType == ExpressionsTypeProvider::intType || leftType == ExpressionsTypeProvider::realType)
	 		&& (rightType == ExpressionsTypeProvider::intType || rightType == ExpressionsTypeProvider::realType) ) {
	 		return
	 	}
	 	else {
	 		checkNotBoolean(leftType, ModuleDslPackage.Literals.ADD__LEFT)
	 		checkNotBoolean(rightType, ModuleDslPackage.Literals.ADD__RIGHT)
	 		
	 		checkNotEnum(leftType, ModuleDslPackage.Literals.ADD__LEFT)
	 		checkNotEnum(rightType, ModuleDslPackage.Literals.ADD__RIGHT)
	 		
	 		checkExpectedSame(leftType, rightType)
	 	}
	 	
	 }
	 
	 
}
